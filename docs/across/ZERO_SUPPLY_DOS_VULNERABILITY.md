# FIXED: Zero Supply DOS Vulnerability

## Summary

**Severity**: ~~CRITICAL~~ **FIXED**
**Status**: ~~IDENTIFIED~~ **RESOLVED**
**Fix Date**: January 2026
**Solution**: Account for pre-existing token balances using `previouslyActive` flag

## Vulnerability Description (Historical)

When a pool had **zero supply on the destination chain** (either fresh pool or all tokens burned), an attacker could DOS legitimate cross-chain transfers by pre-funding the pool with the same token before the first donation.

### Original Attack Vector
1. Pool has zero supply (fresh or burned)
2. Attacker sends TokenA to pool (e.g., 100 USDC) - token NOT in active tokens yet
3. First `donate(TokenA, 1)` unlocks the pool, stores NAV/assets
4. Legitimate `donate(TokenA, amount)` arrives with actual transfer
5. Token balance increased by: pre-existing 100 + new donation
6. But NAV validation only expected: new donation amount
7. NavManipulationDetected check fails → DOS

The critical issue: **storedAssets was captured before the token was activated**, so pre-existing balances weren't included in the asset calculation.

## Fix Implementation

### Root Cause Analysis
The vulnerability stemmed from the timing of token activation:
1. **First `donate(amount=1)` call**: Stores balance, NAV, and assets in transient storage
2. **Second `donate(amount=X)` call**: Activates token, then validates NAV
3. **Problem**: If token wasn't active during first call, its balance wasn't in storedAssets
4. **Attack**: Attacker sends tokens before first call → balance exists but not in storedAssets

### Solution: Track `previouslyActive` Flag

The fix recognizes whether the token was already active (included in NAV) during the unlock phase.

**Why this works:**

When validating asset changes, we need to account for:
- **Case 1**: Token was active during unlock → `storedAssets` includes any pre-existing balance
  - Expected increase: `amountDelta` (actual tokens received)
  
- **Case 2**: Token was NOT active during unlock → `storedAssets` excludes pre-existing balance
  - Expected increase: `storedBalance + amountDelta` (pre-existing + received)

### Implementation

```solidity
// ECrosschain.sol - donate() second call
bool previouslyActive = StorageLib.isOwnedToken(token);

// Activate token after transfer (addUnique is idempotent)
StorageLib.activeTokensSet().addUnique(IEOracle(address(this)), token, StorageLib.pool().baseToken);

if (params.opType == OpType.Transfer) {
    _handleTransferMode(token, amount, amountDelta, storedBalance, previouslyActive);
}

// ECrosschain.sol - _handleTransferMode() validation
uint256 storedAssets = TransientStorage.getStoredAssets();

// Two cases:
// 1. Token was already active → storedAssets includes storedBalance, only add amountDelta
// 2. Token was NOT active → storedAssets excludes storedBalance, add full balance
if (!previouslyActive) {
    // Case 2: Add full current balance (storedBalance + amountDelta)
    amountDelta += storedBalance;
}

// Convert delta to base token value
if (amountDelta > 0) {
    storedAssets += IEOracle(address(this))
        .convertTokenAmount(token, amountDelta.toInt256(), baseToken)
        .toUint256();
}

require(finalAssets == storedAssets, NavManipulationDetected(storedAssets, finalAssets));
```

### Why This Works

**Security Model:**

1. **Token already active** (`previouslyActive = true`):
   - Token was in pool during first `donate(amount=1)` call
   - `storedBalance` was included in `storedAssets` 
   - Only validate the new `amountDelta` increase
   - Prevents operator from swapping pool tokens into donated token

2. **Token NOT active** (`previouslyActive = false`):
   - Token wasn't in pool (or not active) during unlock
   - `storedBalance` was NOT in `storedAssets`
   - Must add both `storedBalance` + `amountDelta` to expected assets
   - Any pre-existing balance (attacker gift, dust, fees) gets properly accounted for
   - First legitimate donator gets this value correctly attributed

**Key DOS Prevention**: By checking `previouslyActive`, we correctly handle pre-existing balances that weren't included in the initial NAV snapshot.

### Surplus Handling

The implementation naturally handles solver surplus:
- `amount`: The expected donation amount (from Across message)
- `amountDelta`: Actual balance change (amount + surplus)
- `require(amountDelta >= amount)` ensures we got at least what we expected
- Virtual supply uses `amount` (donated value for cross-chain accounting)
- Validation uses `amountDelta` (actual value including surplus = positive NAV)

### Benefits

1. **Simple**: Single boolean check, no complex token clearing logic
2. **Gas efficient**: No loops through active tokens, no token transfers
3. **Secure**: Properly handles both normal and DOS scenarios
4. **Correct surplus handling**: `amountDelta` naturally includes solver surplus
5. **Pre-existing value preserved**: Attacker gifts or dust benefit first legitimate donator

## Code Changes

### Files Modified
- [`ECrosschain.sol`](../../contracts/protocol/extensions/ECrosschain.sol)
  - Added `previouslyActive = StorageLib.isOwnedToken(token)` check
  - Pass `previouslyActive` to `_handleTransferMode()`
  - In validation: add `storedBalance` to `amountDelta` if `!previouslyActive`

## Test Cases

```solidity
// Test DOS prevention
function test_ECrosschain_PreFundedToken_NotActiveBeforeDonation() public {
    // Attacker pre-funds pool with USDC
    vm.prank(attacker);
    usdc.transfer(address(pool), 100e6);
    
    // Token not yet active
    assertFalse(pool.isOwnedToken(address(usdc)));
    
    // Legitimate donation succeeds (pre-existing balance accounted for)
    vm.prank(spokePool);
    pool.handleV3AcrossMessage(usdc, 1000e6, relayer, message);
    
    // Token now active, both balances included
    assertTrue(pool.isOwnedToken(address(usdc)));
}
```

## Related Issues

- [PERFORMANCE_ATTRIBUTION.md](PERFORMANCE_ATTRIBUTION.md) - VS-only model documentation
- [IMPLEMENTATION_GUIDE.md](IMPLEMENTATION_GUIDE.md) - Technical implementation details

# CRITICAL: Zero Supply DOS Vulnerability

## Summary

**Severity**: CRITICAL
**Status**: IDENTIFIED - Requires immediate mitigation
**Attack Cost**: Low (1 USDC can block 1000+ USDC transfer)
**Impact**: Permanent denial of service until supply is created

## Vulnerability Description

When a pool has **zero supply on the destination chain**, an attacker can permanently block legitimate cross-chain transfers by front-running them with dust donations.

### Attack Mechanics

1. **Precondition**: Destination pool has `totalSupply = 0`
   - New pool that hasn't been used yet
   - Pool where all tokens were burned
   - Pool where supply exists on other chains but not this one

2. **Attack**: Attacker monitors mempool for incoming cross-chain transfers
   - Sees legitimate `handleV3AcrossMessage` about to be called
   - Front-runs by sending dust (even 1 wei) to the destination pool
   - When legitimate transfer's `donate()` executes, it sees:
     - `totalSupply = 0`
     - Pool assets increased (from attacker's dust)
     - `NavManipulationDetected` triggers

3. **Impact**: Legitimate transfer is **permanently blocked**
   - Transfer cannot complete
   - Pool is locked - no further donations possible
   - Only recovery: Someone must `mint()` to create supply

### Code Location

File: [`contracts/protocol/extensions/ECrosschain.sol`](../../contracts/protocol/extensions/ECrosschain.sol)

```solidity
// Line 160: NavManipulationDetected check
require(poolTokens.totalSupply > 0, "Effective total supply is zero - cannot calculate NAV increase");

// Line 165: Revert if NAV mismatch
require(finalNav == expectedNav, NavManipulationDetected(expectedNav, finalNav));
```

The check was designed to prevent NAV manipulation, but creates a DOS vector when `totalSupply = 0`.

## Proof of Concept

See test: [`test_ECrosschain_DOSAttack_FrontRunTransferToZeroSupplyPool()`](../../test/extensions/AIntentsRealFork.t.sol#L2970)

```
Attacker Cost: 1 USDC
Legitimate Transfer Blocked: 1000 USDC
Result: Pool permanently locked until someone mints
```

## Attack Scenarios

### Scenario 1: New Pool Launch
```
1. Pool deployed on Source Chain
2. Pool deployed on Destination Chain (supply = 0)
3. User initiates first cross-chain transfer
4. Attacker front-runs with dust → DOS
5. First user's transfer permanently blocked
```

### Scenario 2: Supply Burned
```
1. Pool exists on both chains
2. All supply burned on Destination Chain (e.g., all LPs exit)
3. User tries to transfer from Source → Destination
4. Attacker front-runs with dust → DOS
5. Transfer permanently blocked
```

### Scenario 3: Multi-Chain Imbalance
```
1. Pool has supply on Ethereum, Arbitrum, Base
2. New chain added (e.g., Unichain) with supply = 0
3. User initiates transfer to new chain
4. Attacker front-runs with dust → DOS
5. Cross-chain expansion blocked
```

## Impact Analysis

### Economic Impact
- **Attack Cost**: Minimal (1 USDC)
- **Damage**: Blocks transfers of any size
- **Recovery Cost**: Requires someone to mint to create supply

### Operational Impact
- **Permanent Lock**: Pool cannot receive cross-chain transfers until supply created
- **User Experience**: Transfers fail with no clear error message
- **Protocol Risk**: Attackers can block cross-chain expansion

### Likelihood
- **HIGH**: Easy to execute, low cost
- **Monitoring**: Attackers can watch mempool for incoming transfers
- **Target**: Any pool with zero supply on any chain

## Root Cause

The `NavManipulationDetected` check is too strict when `totalSupply = 0`:

```solidity
// Current implementation
require(poolTokens.totalSupply > 0, "Effective total supply is zero - cannot calculate NAV increase");
```

This was intended to prevent NAV manipulation attacks, but creates a DOS vector by:
1. Preventing any donations to zero-supply pools
2. Not distinguishing between malicious and legitimate donations
3. Not providing a recovery mechanism within the same transaction

## Proposed Mitigations

### Option 1: Allow First Donation (Recommended)
Allow donations to zero-supply pools but require minimum supply afterward:

```solidity
// If zero supply, skip NAV check but require mint immediately after
if (poolTokens.totalSupply == 0) {
    // First donation - skip NAV validation
    // But emit warning event
    emit FirstDonationToEmptyPool(token, amount);
    
    // Require supply to be created within same block/transaction
    // to prevent orphaned donations
} else {
    // Normal NAV validation
    require(finalNav == expectedNav, NavManipulationDetected(expectedNav, finalNav));
}
```

### Option 2: Virtual Supply Bootstrap
Create virtual supply during first donation:

```solidity
if (poolTokens.totalSupply == 0) {
    // Create bootstrap virtual supply = donation value / initialNAV
    uint256 bootstrapShares = (donationValue * 10**decimals) / initialNAV;
    VirtualStorageLib.setVirtualSupply(bootstrapShares.toInt256());
    
    // Now NAV check will pass
}
```

### Option 3: Trusted First Donation
Require first donation to come from pool owner:

```solidity
if (poolTokens.totalSupply == 0) {
    require(msg.sender == poolOwner || msg.sender == trustedHandler, "First donation must be from owner");
}
```

### Option 4: Minimum Supply Requirement
Require pools to maintain minimum supply on all chains:

```solidity
// In burn() function
require(newSupply >= MIN_SUPPLY || newSupply == 0, "Cannot reduce below minimum supply");

// Where MIN_SUPPLY = 1e6 (enough to prevent DOS while small enough to not trap value)
```

## Recommended Solution

**Implement Option 4 (Minimum Supply) + Option 1 (First Donation)**:

1. Prevent supply from being burned to zero (except complete exit)
2. If supply reaches zero, allow first donation with special handling
3. Emit events to track first-donation scenarios
4. Consider requiring minimum liquidity on new chain deployments

## Timeline

- **Identified**: January 2026
- **Severity**: CRITICAL
- **Priority**: Immediate fix required before production deployment
- **Affected**: All pools with potential for zero supply on any chain

## Testing

Test coverage added:
- ✅ `test_ECrosschain_EmptyPool_FirstDonation_InitializesAndIncreasesNav()` - Documents the issue
- ✅ `test_ECrosschain_DOSAttack_FrontRunTransferToZeroSupplyPool()` - Proves the exploit

## References

- [ECrosschain.sol](../../contracts/protocol/extensions/ECrosschain.sol#L160)
- [Test cases](../../test/extensions/AIntentsRealFork.t.sol#L2840)
- [Virtual storage implementation](../../contracts/protocol/libraries/VirtualStorageLib.sol)

## Action Items

- [ ] Review and select mitigation strategy
- [ ] Implement fix
- [ ] Add comprehensive test coverage
- [ ] Security audit of fix
- [ ] Deploy to testnet
- [ ] Monitor for attack attempts
- [ ] Consider upgrading existing pools
- [ ] Update deployment procedures to ensure minimum supply

---

**Note**: This vulnerability was discovered through edge case testing of the `totalSupply = 0` scenario. While the `NavManipulationDetected` check was added for security, it inadvertently created a DOS vector that must be addressed before production deployment.

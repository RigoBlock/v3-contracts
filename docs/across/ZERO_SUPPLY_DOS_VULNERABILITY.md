# ~~CRITICAL~~: FIXED - Zero Supply DOS Vulnerability

## Summary

**Severity**: ~~CRITICAL~~ **FIXED**
**Status**: ~~IDENTIFIED~~ **RESOLVED**
**Fix Date**: January 2026
**Solution**: NAV initialization on first donate() call

## Vulnerability Description (Historical)

When a pool had **zero supply on the destination chain**, an attacker could have blocked legitimate cross-chain transfers by sending dust between the two `donate()` calls.

## Fix Implementation

### Root Cause
The issue was that `NavManipulationDetected` check compared:
- `expectedNav` (based on legitimate transfer amount)
- `finalNav` (based on actual pool balance)

If tokens were sent BETWEEN the two donate() calls, they would affect `finalNav` but not `expectedNav`, causing a mismatch.

### Solution
Initialize NAV on the FIRST `donate()` call if storage slot is empty:

```solidity
// In donate() when amount == 1 (initialization call)
// Check if NAV has ever been initialized
bytes32 poolTokensSlot = StorageLib.POOL_TOKENS_SLOT;
uint256 storedValue;
assembly {
    storedValue := sload(poolTokensSlot)
}

// updateUnitaryValue() will initialize NAV if storedValue == 0
// Once initialized, storage will never be 0 again (even if supply goes to 0)
uint256 currentNav = ISmartPoolActions(address(this)).updateUnitaryValue();
currentNav.storeNav();
```

### Why This Works
1. **First-time pools**: Storage slot is 0, NAV gets initialized to `10^decimals`
2. **Used pools**: Storage slot has value, NAV is just updated
3. **Attack prevention**: NAV is locked BEFORE attacker can send tokens
4. **Clean slate**: Only tokens sent BETWEEN donate calls affect NAV validation

### Key Insight
The NAV check now properly captures ONLY what happens between the two `donate()` calls:
- Everything before first `donate()`: Irrelevant (NAV initialized)
- Everything between donate calls: Captured by NAV validation
- Attack tokens sent between calls: Detected as unexpected NAV change

## Code Changes

### Files Modified
- [`ECrosschain.sol`](../../contracts/protocol/extensions/ECrosschain.sol)
  - Added `EffectiveSupplyZero` custom error (replaced revert string)
  - Initialize NAV on first donate() if storage empty
  - Fixed redundant `expectedNav` initialization
  - Proper NAV validation captures intermediate state changes

- [`StorageLib.sol`](../../contracts/protocol/libraries/StorageLib.sol)
  - Added `POOL_TOKENS_SLOT` constant for direct storage access

## Testing

### Test Coverage
- ✅ `test_ECrosschain_EmptyPool_FirstDonation_InitializesAndIncreasesNav()`
  - Verifies NAV initialization when storage is empty
  - Confirms NavManipulationDetected still protects against zero-supply donations
  - Tests normal operation after supply established

- ✅ All existing `test_IntegrationFork_ECrosschain_*` tests pass
  - Confirms fix doesn't break existing functionality
  - Virtual balance/supply mechanics unaffected
  - WETH unwrapping works correctly

## Impact Analysis

### Before Fix
- **Attack Cost**: 1 USDC could block 1000+ USDC transfers
- **Impact**: Permanent DOS until someone mints
- **Likelihood**: HIGH (easy to execute, low cost)

### After Fix
- **Attack Prevention**: NAV initialized before attack window
- **Attack Detection**: Unexpected tokens detected via NAV mismatch
- **Normal Operation**: Unaffected - NAV already initialized for used pools
- **First-Time Pools**: Properly initialize without vulnerability

## Edge Cases Handled

1. **Brand new pool**: Storage = 0, NAV initialized to `10^decimals`
2. **Pool with burned supply**: Storage ≠ 0 (NAV was previously set), just update
3. **Multi-chain imbalance**: Each chain initializes independently
4. **Attack attempt**: Tokens sent between donate calls detected as NAV manipulation

## Historical Context

This vulnerability was discovered through edge case testing where pool storage was cleared to simulate a brand new pool. The testing revealed that:
- `getPoolTokens()` auto-initializes NAV even when storage is 0
- First `donate()` call writes initialized NAV to storage
- Attacker could exploit the window between initialization and validation

The fix ensures NAV is locked at initialization, closing the attack window.

## References

- [ECrosschain.sol](../../contracts/protocol/extensions/ECrosschain.sol)
- [Test cases](../../test/extensions/AIntentsRealFork.t.sol#L2840)
- [StorageLib.sol](../../contracts/protocol/libraries/StorageLib.sol)

# ~~CRITICAL~~: FIXED - Zero Supply DOS Vulnerability

## Summary

**Severity**: ~~CRITICAL~~ **FIXED**
**Status**: ~~IDENTIFIED~~ **RESOLVED**
**Fix Date**: January 2026
**Solution**: Account for pre-existing token balances using `previouslyActive` flag

## Vulnerability Description (Historical)

When a pool had **zero supply on the destination chain** (either fresh pool or all tokens burned), an attacker could DOS legitimate cross-chain transfers by pre-funding the pool with the same token before the first donation.

### Original Attack Vector
1. Pool has zero supply (fresh or burned)
2. Attacker sends TokenA to pool (e.g., 100 USDC) - token NOT in active tokens yet
3. First `donate(TokenA, 1)` unlocks the pool, stores NAV/assets
4. Legitimate `donate(TokenA, amount)` arrives with actual transfer
5. Token balance increased by: pre-existing 100 + new donation
6. But NAV validation only expected: new donation amount
7. NavManipulationDetected check fails → DOS

The critical issue: **storedAssets was captured before the token was activated**, so pre-existing balances weren't included in the asset calculation.

## Fix Implementation

### Root Cause Analysis
The vulnerability stemmed from the timing of token activation:
1. **First `donate(amount=1)` call**: Stores balance, NAV, and assets in transient storage
2. **Second `donate(amount=X)` call**: Activates token, then validates NAV
3. **Problem**: If token wasn't active during first call, its balance wasn't in storedAssets
4. **Attack**: Attacker sends tokens before first call → balance exists but not in storedAssets

### Solution: Track `previouslyActive` Flag

The fix recognizes whether the token was already active (included in NAV) during the unlock phase.

**Why this works:**

When validating asset changes, we need to account for:
- **Case 1**: Token was active during unlock → `storedAssets` includes any pre-existing balance
  - Expected increase: `amountDelta` (actual tokens received)
  
- **Case 2**: Token was NOT active during unlock → `storedAssets` excludes pre-existing balance
  - Expected increase: `storedBalance + amountDelta` (pre-existing + received)

### Implementation

```solidity
// ECrosschain.sol - donate() second call (lines 88-96)
bool previouslyActive = StorageLib.isOwnedToken(token);

// Activate token after transfer (addUnique is idempotent)
StorageLib.activeTokensSet().addUnique(IEOracle(address(this)), token, StorageLib.pool().baseToken);

if (params.opType == OpType.Transfer) {
    _handleTransferMode(token, amount, amountDelta, storedBalance, previouslyActive);
}

// ECrosschain.sol - _handleTransferMode() validation (lines 158-178)
uint256 storedAssets = TransientStorage.getStoredAssets();

// Two cases:
// 1. Token was already active → storedAssets includes storedBalance, only add amountDelta
// 2. Token was NOT active → storedAssets excludes storedBalance, add full balance
if (!previouslyActive) {
    // Case 2: Add full current balance (storedBalance + amountDelta)
    amountDelta += storedBalance;
}

// Convert delta and account for virtual balance reduction
if (amountDelta > 0) {
    uint256 amountDeltaValueInBase = IEOracle(address(this))
        .convertTokenAmount(token, amountDelta.toInt256(), baseToken)
        .toUint256();
    
    // VB reduction already reflected in finalAssets, don't double-count
    // Note: amountDeltaValueInBase >= vbReductionValueInBase always holds because
    // VB reduction is capped by amountValueInBase and amountDelta >= amount (line 75)
    storedAssets += amountDeltaValueInBase - vbReductionValueInBase;
}

require(finalAssets == storedAssets, NavManipulationDetected(storedAssets, finalAssets));
```

### Why This Works

**Security Model:**

1. **Token already active** (`previouslyActive = true`):
   - Token was in pool during first `donate(amount=1)` call
   - `storedBalance` was included in `storedAssets` 
   - Only validate the new `amountDelta` increase
   - Prevents operator from swapping pool tokens into donated token

2. **Token NOT active** (`previouslyActive = false`):
   - Token wasn't in pool (or not active) during unlock
   - `storedBalance` was NOT in `storedAssets`
   - Must add both `storedBalance` + `amountDelta` to expected assets
   - Any pre-existing balance (attacker gift, dust, fees) gets properly accounted for
   - First legitimate donator gets this value correctly attributed

**Key DOS Prevention**: By checking `previouslyActive`, we correctly handle pre-existing balances that weren't included in the initial NAV snapshot.

### Virtual Balance Accounting

An additional complexity: virtual balance reductions must not be double-counted.

When virtual balance is reduced (tokens returning from another chain):
```solidity
// Track how much VB was reduced (lines 130-145)
uint256 vbReductionValueInBase = 0;

int256 currentBaseTokenVB = baseToken.getVirtualBalance();
if (currentBaseTokenVB > 0) {
    uint256 baseTokenVBUint = currentBaseTokenVB.toUint256();
    if (amountValueInBase >= baseTokenVBUint) {
        // Reduce all VB
        baseToken.updateVirtualBalance(-currentBaseTokenVB);
        vbReductionValueInBase = baseTokenVBUint;
    } else {
        // Reduce by donation amount
        baseToken.updateVirtualBalance(-(amountValueInBase.toInt256()));
        vbReductionValueInBase = amountValueInBase;
    }
}

// VB reduction increases effective assets in updateUnitaryValue()
// So subtract from expected increase to avoid double-counting
storedAssets += amountDeltaValueInBase - vbReductionValueInBase;
```

The VB reduction already increases `finalAssets` (via `updateUnitaryValue()`), so we subtract it from the expected increase to avoid counting it twice.

### Surplus Handling

The implementation naturally handles solver surplus:
- `amount`: The expected donation amount (from Across message)
- `amountDelta`: Actual balance change (amount + surplus)
- `require(amountDelta >= amount)` ensures we got at least what we expected
- Virtual supply uses `amount` (donated value for cross-chain accounting)
- Validation uses `amountDelta` (actual value including surplus = positive NAV)

### Benefits

1. **Simple**: Single boolean check, no complex token clearing logic
2. **Gas efficient**: No loops through active tokens, no token transfers
3. **Secure**: Properly handles both normal and DOS scenarios
4. **Correct surplus handling**: `amountDelta` naturally includes solver surplus
5. **Virtual balance compatible**: Works seamlessly with VB reduction logic
6. **Pre-existing value preserved**: Attacker gifts or dust benefit first legitimate donator

## Code Changes

### Files Modified
- [`ECrosschain.sol`](../../contracts/protocol/extensions/ECrosschain.sol)
  - Added `previouslyActive = StorageLib.isOwnedToken(token)` check (line 90)
  - Pass `previouslyActive` to `_handleTransferMode()` (line 96)
  - In validation: add `storedBalance` to `amountDelta` if `!previouslyActive` (lines 164-167)
  - Track and account for virtual balance reduction (lines 130-178)

### Key Functions
- `donate()`: Captures `previouslyActive` flag before activating token
- `_handleTransferMode()`: Validates assets accounting for:
  - Pre-existing balances (via `previouslyActive`)
  - Virtual balance reduction (to avoid double-counting)
  - Solver surplus (using `amountDelta` vs `amount`)

## Testing

### Test Coverage
- ✅ `test_ECrosschain_PassesWithNullSupplyAndPositiveSameTokenBalance()`
  - Verifies pre-existing balances benefit legitimate donator when supply is zero
  - Attacker gifts 2000 USDC, operator donates 100 USDC
  - Token wasn't active (`previouslyActive = false`)
  - Validation correctly expects: storedAssets + (2000 + 100) = finalAssets
  
- ✅ `test_ECrosschain_PassesWithNullSupplyAndPositiveOtherTokenBalance()`
  - Multi-token DOS scenario: attacker gifts 2000 WETH, donation is 100 USDC
  - WETH was active during unlock, USDC was not
  - Verifies `previouslyActive` correctly distinguishes tokens
  - Pre-existing balances included in NAV for first donator

- ✅ `test_IntegrationFork_ECrosschain_PartialVirtualBalanceReduction()`
  - Fork test with VB = 500 USDC, donation = 300 USDC
  - VB reduced by 300, remainingValueInBase = 0
  - Validates VB reduction is not double-counted in asset calculation

- ✅ `test_IntegrationFork_CrossChain_TransferWithHandler_SameChain()`
  - Fork test with real contracts on Ethereum
  - Multicall with donate → transfer → donate sequence
  - Verifies NAV neutrality with virtual balance management

- ✅ All 21 ECrosschain unit tests pass
  - No regressions in existing functionality
  - Virtual balance/supply mechanics working correctly
  - WETH unwrapping works as expected
  - Surplus handling validated

## Impact Analysis

### Before Fix
- **Attack Cost**: Dust amount (1 wei) could block large transfers indefinitely
- **Impact**: Permanent DOS on fresh pools or after all supply burned
- **Likelihood**: HIGH (easy to execute, low cost, high impact)
- **Detection**: Difficult to detect until first legitimate donation attempts

### After Fix
- **Attack Prevention**: Pre-existing balances correctly accounted for via `previouslyActive`
- **Security Model**: Token activation timing determines whether balance was in storedAssets
- **Gas Efficiency**: Single boolean check, no loops or transfers
- **User Benefit**: Pre-existing balances benefit first legitimate donator
- **Surplus Handling**: Naturally handles solver surplus as positive NAV

## Edge Cases Handled

1. **Fresh pool**: Token not active → add `storedBalance + amountDelta`
2. **Token already active**: Token in NAV → add only `amountDelta`
3. **Multi-token attack**: Each token checked independently for `previouslyActive`
4. **Virtual balance reduction**: Tracked separately, subtracted to avoid double-counting
5. **Solver surplus**: `amountDelta > amount` naturally handled as positive NAV
6. **Zero supply scenarios**: Works regardless of supply (no special case needed)

## Historical Context

This vulnerability was discovered through comprehensive edge case testing during cross-chain integration work.

### Evolution of the Fix

1. **Initial Discovery**: Attacker could send tokens between two `donate()` calls to corrupt NAV
2. **First Attempt**: Check for zero supply, skip NavManipulationDetected
3. **Multi-Token Issue**: Attacker could gift TokenA, donate TokenB
4. **Complex Attempt**: Clear all tokens when supply is zero
   - Problem: New DOS vector (dust to many tokens), gas inefficient
5. **Final Solution**: Track `previouslyActive` to determine if balance was in storedAssets
   - Simpler, more direct, handles all edge cases

### Key Insight

The fundamental issue wasn't about zero supply - it was about **token activation timing**. A token's balance is only included in `storedAssets` if it was already active during the first `donate(amount=1)` call.

By tracking `previouslyActive`, we know whether to expect just the new `amountDelta` or the full balance (`storedBalance + amountDelta`).

## References

- [ECrosschain.sol](../../contracts/protocol/extensions/ECrosschain.sol)
- [StorageLib.sol](../../contracts/protocol/libraries/StorageLib.sol)
- [VirtualStorageLib.sol](../../contracts/protocol/libraries/VirtualStorageLib.sol)
- [Fork Tests](../../test/extensions/AIntentsRealFork.t.sol)
- [Unit Tests](../../test/extensions/ECrosschainUnit.t.sol)
